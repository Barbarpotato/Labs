<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Why You Need Kubernetes: A Comprehensive Guide</title><meta name="description" content="In today&#x27;s fast-paced digital landscape, applications are becoming increasingly complex and distributed. To manage this complexity and ensure high availability, reliability, and scalability, organizations are turning to Kubernetes. This powerful container orchestration platform has revolutionized the way we deploy and manage applications."/><meta property="og:title" content="Why You Need Kubernetes: A Comprehensive Guide"/><meta property="og:description" content="In today&#x27;s fast-paced digital landscape, applications are becoming increasingly complex and distributed. To manage this complexity and ensure high availability, reliability, and scalability, organizations are turning to Kubernetes. This powerful container orchestration platform has revolutionized the way we deploy and manage applications."/><meta property="og:type" content="article"/><meta property="og:url" content="https://barbarpotato.github.io/labs/undefined"/><meta name="next-head-count" content="8"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/Labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/Labs/_next/static/chunks/webpack-a39982bd6f80347b.js" defer=""></script><script src="/Labs/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/Labs/_next/static/chunks/main-1e09b50edce1e67f.js" defer=""></script><script src="/Labs/_next/static/chunks/pages/_app-753213cf38d40131.js" defer=""></script><script src="/Labs/_next/static/chunks/pages/labs/%5Bslug%5D-b6b888b0a2f30cff.js" defer=""></script><script src="/Labs/_next/static/A-n-baZxhaPab-FReiSSJ/_buildManifest.js" defer=""></script><script src="/Labs/_next/static/A-n-baZxhaPab-FReiSSJ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><article><h1>Why You Need Kubernetes: A Comprehensive Guide</h1><p>2024-11-02 23:48:06</p><div><div id="content-0"><p>In today's rapidly evolving technological landscape, applications are becoming increasingly complex and distributed. To manage this complexity and ensure high availability, reliability, and scalability, organizations are turning to Kubernetes. This powerful container orchestration platform has revolutionized the way we deploy and manage applications.</p></div><div id="content-1"><h1>Why Kubernetes?</h1></div><div id="content-2"><p><strong>1. Simplified Deployment and Management:</strong></p><ul><li><strong>Automated Deployment:</strong> Kubernetes automates the deployment process, eliminating manual intervention and reducing the risk of human error. With a few configuration changes, you can deploy complex applications to multiple environments with ease.</li><li><strong>Self-Healing:</strong> Kubernetes can automatically detect and recover from failures, ensuring that your applications remain up and running. If a pod fails, Kubernetes will automatically restart it on a different node.</li><li><strong>Scalability:</strong> You can easily scale your applications up or down to meet changing demand, without requiring significant manual effort. Whether it's a sudden traffic spike or a planned scaling event, Kubernetes can handle it seamlessly.</li></ul></div><div id="content-3"><p><strong>2. Efficient Resource Utilization:</strong></p><ul><li><strong>Resource Allocation:</strong> Kubernetes efficiently allocates resources (CPU, memory) to your applications, maximizing utilization and minimizing waste. It ensures that your applications get the resources they need, while avoiding overprovisioning.</li><li><strong>Dynamic Scheduling:</strong> It intelligently schedules pods onto nodes, optimizing resource allocation across the cluster. This ensures that your applications are always running on the most suitable nodes, regardless of their resource requirements.</li></ul><p><strong>3. Enhanced Reliability and Availability:</strong></p><ul><li><strong>High Availability:</strong> Kubernetes ensures high availability by replicating your applications across multiple nodes, providing redundancy and fault tolerance. If one node fails, your application will continue to run on other nodes.</li><li><strong>Load Balancing:</strong> It automatically distributes traffic across multiple instances of your application, improving performance and reliability. This ensures that no single instance is overwhelmed, and your users get a consistent experience.</li></ul><p><strong>4. Increased Flexibility and Portability:</strong></p><ul><li><strong>Container-Based:</strong> Kubernetes is container-based, allowing you to package your applications and their dependencies into portable units. This makes it easy to move your applications between different environments, such as development, testing, and production.</li><li><strong>Platform Agnostic:</strong> It can run on various infrastructure platforms, including public clouds (AWS, Azure, GCP), private clouds, and on-premises data centers. This gives you the flexibility to choose the best platform for your needs.</li></ul><p><br></p></div><div id="content-4"><h1>Kubernetes Architecture</h1></div><div id="content-6"><img style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fkubernetes-architecture.png?alt=media&token=cd32c87e-d584-4aec-a83f-f0c20d7d0f5c'/></div><div id="content-7"><p>This diagram provides a clear overview of the key components in a Kubernetes cluster and how they interact with each other. Let's break down each component:</p><p><strong>Control Plane</strong></p><ul><li><strong>API Server:</strong> The main entry point for all interactions with the cluster. All requests (e.g., creating a new pod, scaling a deployment) are sent to the API Server.</li><li><strong>etcd:</strong> A distributed, consistent, highly-available key-value store that stores the entire cluster state. All information about pods, services, deployments, and more is stored here.</li><li><strong>Controller Manager:</strong> Manages various controllers responsible for ensuring the cluster is in the desired state. Examples of controllers include Deployment Controller, ReplicaSet Controller, and Job Controller.</li><li><strong>Scheduler:</strong> Responsible for scheduling pods to available nodes. It considers various factors like resource availability, affinities, and anti-affinities.</li></ul><p><strong>Node</strong></p><ul><li><strong>Kubelet:</strong> An agent that runs on each node. Kubelet ensures that the containers specified in pod manifests are running on the node.</li><li><strong>kube-proxy:</strong> A network proxy that implements network rules for services and load balancing.</li></ul><p><strong>Component Interactions</strong></p><ol><li><strong>User or Tool:</strong> When you want to create or manage Kubernetes resources (e.g., using kubectl), you interact with the API Server.</li><li><strong>API Server:</strong> Receives the request, validates it, and stores it in etcd.</li><li><strong>Controller Manager:</strong> Monitors changes in etcd and takes necessary actions. For example, if the number of replicas for a deployment doesn't match the desired state, the controller will create or delete pods.</li><li><strong>Scheduler:</strong> When there's a new pod to be scheduled, the scheduler selects the most suitable node and informs the Kubelet.</li><li><strong>Kubelet:</strong> Receives information from the scheduler and starts running the pod's containers.</li><li><strong>kube-proxy:</strong> Manages networking to ensure traffic is routed to the correct pods.</li></ol><p><br></p></div><div id="content-8"><h1><strong>Deployments: Scale, Update, Rollback</strong></h1><p>Imagine you have a simple web application (e.g., a Node.js app) running in a Kubernetes cluster. The application is exposed via a Kubernetes Service, and you want to manage it using a Deployment. Hereâ€™s how you can implement this:</p></div><div id="content-9"><h2>1. <strong>Creating a Deployment</strong></h2><p>First, you'll create a Deployment to manage your application.</p></div><div id="content-10"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-web-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-web-app
  template:
    metadata:
      labels:
        app: my-web-app
    spec:
      containers:
        - name: my-web-app
          image: myusername/my-web-app:1.0
          ports:
            - containerPort: 80</code></pre></div><div id="content-11"><ul><li><strong>Replicas</strong>: This specifies how many pods you want to run.</li><li><strong>Selector</strong>: This defines how to identify the pods managed by this Deployment.</li><li><strong>Template</strong>: This describes the pods that will be created.</li></ul><p><strong>Deploying the Application</strong>: Apply the Deployment with the following command:</p></div><div id="content-12"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">kubectl apply -f deployment.yaml</code></pre></div><div id="content-13"><h2>2. <strong>Scaling the Application</strong></h2><p>If you want to handle increased traffic, you can scale your Deployment up or down.</p><p><strong>Scaling Up</strong>: To increase the number of replicas to 5:</p></div><div id="content-16"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">kubectl scale deployment my-web-app --replicas=5</code></pre></div><div id="content-17"><p>Scaling Down: To decrease the number of replicas back to 3:</p></div><div id="content-18"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">kubectl scale deployment my-web-app --replicas=3</code></pre></div><div id="content-19"><h2>3. <strong>Updating the Application</strong></h2><p>When you want to update your application (for example, deploying a new version of the image), modify the Deployment:</p></div><div id="content-21"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">spec:
  template:
    spec:
      containers:
        - name: my-web-app
          image: myusername/my-web-app:2.0 # Updated version</code></pre></div><div id="content-22"><p>Applying the Update: You can update the Deployment by reapplying the configuration:</p></div><div id="content-23"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">kubectl apply -f deployment.yaml</code></pre></div><div id="content-24"><p>Kubernetes will perform a rolling update, gradually replacing the old pods with new ones.</p><h2>4. <strong>Checking the Update Status</strong></h2><p>To monitor the status of the update, use:</p></div><div id="content-25"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">kubectl rollout status deployment/my-web-app</code></pre></div><div id="content-26"><h2>5. <strong>Rolling Back an Update</strong></h2><p>If something goes wrong with the new version, you can roll back to the previous version easily:</p></div><div id="content-27"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">kubectl rollout undo deployment/my-web-app</code></pre></div><div id="content-28"><p>To check the history of the revisions, you can use:</p></div><div id="content-29"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">kubectl rollout history deployment/my-web-app</code></pre></div><div id="content-30"><h2>6. <strong>Verifying the Rollback</strong></h2><p>After rolling back, you can verify that the previous version is running:</p></div><div id="content-31"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">kubectl get deployments
kubectl describe deployment my-web-app</code></pre></div><div id="content-32"><h2>7. <strong>Creating a Service</strong></h2><p>A Kubernetes <strong>Service</strong> is used to expose your application, making it accessible from outside the cluster (or within, depending on your requirements). Here's an example of a Service configuration:</p></div><div id="content-33"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">apiVersion: v1
kind: Service
metadata:
  name: my-web-app-service
spec:
  selector:
    app: my-web-app
  ports:
    - protocol: TCP
      port: 80       # Port on the Service
      targetPort: 80 # Port on the container
  type: LoadBalancer</code></pre></div><div id="content-34"><h1><strong>In Conclusion:</strong></h1><p>Kubernetes architecture is designed to simplify the management of large-scale containerized applications. By understanding its components and interactions, you can effectively leverage Kubernetes to build reliable and scalable applications.</p></div></div></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"blog_id":"4a5ae2d7-0f8f-46b9-b49a-4ff130f22292","description":"\u003cdiv id=\"content-0\"\u003e\u003cp\u003eIn today's rapidly evolving technological landscape, applications are becoming increasingly complex and distributed. To manage this complexity and ensure high availability, reliability, and scalability, organizations are turning to Kubernetes. This powerful container orchestration platform has revolutionized the way we deploy and manage applications.\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-1\"\u003e\u003ch1\u003eWhy Kubernetes?\u003c/h1\u003e\u003c/div\u003e\u003cdiv id=\"content-2\"\u003e\u003cp\u003e\u003cstrong\u003e1. Simplified Deployment and Management:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eAutomated Deployment:\u003c/strong\u003e Kubernetes automates the deployment process, eliminating manual intervention and reducing the risk of human error. With a few configuration changes, you can deploy complex applications to multiple environments with ease.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eSelf-Healing:\u003c/strong\u003e Kubernetes can automatically detect and recover from failures, ensuring that your applications remain up and running. If a pod fails, Kubernetes will automatically restart it on a different node.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eScalability:\u003c/strong\u003e You can easily scale your applications up or down to meet changing demand, without requiring significant manual effort. Whether it's a sudden traffic spike or a planned scaling event, Kubernetes can handle it seamlessly.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv id=\"content-3\"\u003e\u003cp\u003e\u003cstrong\u003e2. Efficient Resource Utilization:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eResource Allocation:\u003c/strong\u003e Kubernetes efficiently allocates resources (CPU, memory) to your applications, maximizing utilization and minimizing waste. It ensures that your applications get the resources they need, while avoiding overprovisioning.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eDynamic Scheduling:\u003c/strong\u003e It intelligently schedules pods onto nodes, optimizing resource allocation across the cluster. This ensures that your applications are always running on the most suitable nodes, regardless of their resource requirements.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e3. Enhanced Reliability and Availability:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eHigh Availability:\u003c/strong\u003e Kubernetes ensures high availability by replicating your applications across multiple nodes, providing redundancy and fault tolerance. If one node fails, your application will continue to run on other nodes.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLoad Balancing:\u003c/strong\u003e It automatically distributes traffic across multiple instances of your application, improving performance and reliability. This ensures that no single instance is overwhelmed, and your users get a consistent experience.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e4. Increased Flexibility and Portability:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eContainer-Based:\u003c/strong\u003e Kubernetes is container-based, allowing you to package your applications and their dependencies into portable units. This makes it easy to move your applications between different environments, such as development, testing, and production.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003ePlatform Agnostic:\u003c/strong\u003e It can run on various infrastructure platforms, including public clouds (AWS, Azure, GCP), private clouds, and on-premises data centers. This gives you the flexibility to choose the best platform for your needs.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-4\"\u003e\u003ch1\u003eKubernetes Architecture\u003c/h1\u003e\u003c/div\u003e\u003cdiv id=\"content-6\"\u003e\u003cimg style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fkubernetes-architecture.png?alt=media\u0026token=cd32c87e-d584-4aec-a83f-f0c20d7d0f5c'/\u003e\u003c/div\u003e\u003cdiv id=\"content-7\"\u003e\u003cp\u003eThis diagram provides a clear overview of the key components in a Kubernetes cluster and how they interact with each other. Let's break down each component:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eControl Plane\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eAPI Server:\u003c/strong\u003e The main entry point for all interactions with the cluster. All requests (e.g., creating a new pod, scaling a deployment) are sent to the API Server.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eetcd:\u003c/strong\u003e A distributed, consistent, highly-available key-value store that stores the entire cluster state. All information about pods, services, deployments, and more is stored here.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eController Manager:\u003c/strong\u003e Manages various controllers responsible for ensuring the cluster is in the desired state. Examples of controllers include Deployment Controller, ReplicaSet Controller, and Job Controller.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eScheduler:\u003c/strong\u003e Responsible for scheduling pods to available nodes. It considers various factors like resource availability, affinities, and anti-affinities.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eNode\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eKubelet:\u003c/strong\u003e An agent that runs on each node. Kubelet ensures that the containers specified in pod manifests are running on the node.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003ekube-proxy:\u003c/strong\u003e A network proxy that implements network rules for services and load balancing.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eComponent Interactions\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eUser or Tool:\u003c/strong\u003e When you want to create or manage Kubernetes resources (e.g., using kubectl), you interact with the API Server.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eAPI Server:\u003c/strong\u003e Receives the request, validates it, and stores it in etcd.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eController Manager:\u003c/strong\u003e Monitors changes in etcd and takes necessary actions. For example, if the number of replicas for a deployment doesn't match the desired state, the controller will create or delete pods.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eScheduler:\u003c/strong\u003e When there's a new pod to be scheduled, the scheduler selects the most suitable node and informs the Kubelet.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eKubelet:\u003c/strong\u003e Receives information from the scheduler and starts running the pod's containers.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003ekube-proxy:\u003c/strong\u003e Manages networking to ensure traffic is routed to the correct pods.\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-8\"\u003e\u003ch1\u003e\u003cstrong\u003eDeployments: Scale, Update, Rollback\u003c/strong\u003e\u003c/h1\u003e\u003cp\u003eImagine you have a simple web application (e.g., a Node.js app) running in a Kubernetes cluster. The application is exposed via a Kubernetes Service, and you want to manage it using a Deployment. Hereâ€™s how you can implement this:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-9\"\u003e\u003ch2\u003e1. \u003cstrong\u003eCreating a Deployment\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eFirst, you'll create a Deployment to manage your application.\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-10\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003eapiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-web-app\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: my-web-app\n  template:\n    metadata:\n      labels:\n        app: my-web-app\n    spec:\n      containers:\n        - name: my-web-app\n          image: myusername/my-web-app:1.0\n          ports:\n            - containerPort: 80\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-11\"\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eReplicas\u003c/strong\u003e: This specifies how many pods you want to run.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eSelector\u003c/strong\u003e: This defines how to identify the pods managed by this Deployment.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eTemplate\u003c/strong\u003e: This describes the pods that will be created.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eDeploying the Application\u003c/strong\u003e: Apply the Deployment with the following command:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-12\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003ekubectl apply -f deployment.yaml\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-13\"\u003e\u003ch2\u003e2. \u003cstrong\u003eScaling the Application\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eIf you want to handle increased traffic, you can scale your Deployment up or down.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eScaling Up\u003c/strong\u003e: To increase the number of replicas to 5:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-16\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003ekubectl scale deployment my-web-app --replicas=5\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-17\"\u003e\u003cp\u003eScaling Down: To decrease the number of replicas back to 3:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-18\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003ekubectl scale deployment my-web-app --replicas=3\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-19\"\u003e\u003ch2\u003e3. \u003cstrong\u003eUpdating the Application\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eWhen you want to update your application (for example, deploying a new version of the image), modify the Deployment:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-21\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003espec:\n  template:\n    spec:\n      containers:\n        - name: my-web-app\n          image: myusername/my-web-app:2.0 # Updated version\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-22\"\u003e\u003cp\u003eApplying the Update: You can update the Deployment by reapplying the configuration:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-23\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003ekubectl apply -f deployment.yaml\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-24\"\u003e\u003cp\u003eKubernetes will perform a rolling update, gradually replacing the old pods with new ones.\u003c/p\u003e\u003ch2\u003e4. \u003cstrong\u003eChecking the Update Status\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eTo monitor the status of the update, use:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-25\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003ekubectl rollout status deployment/my-web-app\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-26\"\u003e\u003ch2\u003e5. \u003cstrong\u003eRolling Back an Update\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eIf something goes wrong with the new version, you can roll back to the previous version easily:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-27\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003ekubectl rollout undo deployment/my-web-app\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-28\"\u003e\u003cp\u003eTo check the history of the revisions, you can use:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-29\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003ekubectl rollout history deployment/my-web-app\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-30\"\u003e\u003ch2\u003e6. \u003cstrong\u003eVerifying the Rollback\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eAfter rolling back, you can verify that the previous version is running:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-31\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003ekubectl get deployments\nkubectl describe deployment my-web-app\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-32\"\u003e\u003ch2\u003e7. \u003cstrong\u003eCreating a Service\u003c/strong\u003e\u003c/h2\u003e\u003cp\u003eA Kubernetes \u003cstrong\u003eService\u003c/strong\u003e is used to expose your application, making it accessible from outside the cluster (or within, depending on your requirements). Here's an example of a Service configuration:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-33\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003eapiVersion: v1\nkind: Service\nmetadata:\n  name: my-web-app-service\nspec:\n  selector:\n    app: my-web-app\n  ports:\n    - protocol: TCP\n      port: 80       # Port on the Service\n      targetPort: 80 # Port on the container\n  type: LoadBalancer\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-34\"\u003e\u003ch1\u003e\u003cstrong\u003eIn Conclusion:\u003c/strong\u003e\u003c/h1\u003e\u003cp\u003eKubernetes architecture is designed to simplify the management of large-scale containerized applications. By understanding its components and interactions, you can effectively leverage Kubernetes to build reliable and scalable applications.\u003c/p\u003e\u003c/div\u003e","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2FKubernetes-logo-1024x576.png?alt=media\u0026token=e6f56ef1-e429-4d8f-9597-2d5a01023cf9","image_alt":"Kubernetes Logo","short_description":"In today's fast-paced digital landscape, applications are becoming increasingly complex and distributed. To manage this complexity and ensure high availability, reliability, and scalability, organizations are turning to Kubernetes. This powerful container orchestration platform has revolutionized the way we deploy and manage applications.","timestamp":"2024-11-02 23:48:06","title":"Why You Need Kubernetes: A Comprehensive Guide"}},"__N_SSG":true},"page":"/labs/[slug]","query":{"slug":"4a5ae2d7-0f8f-46b9-b49a-4ff130f22292"},"buildId":"A-n-baZxhaPab-FReiSSJ","assetPrefix":"/Labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>