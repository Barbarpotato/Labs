<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Create GRPC With MongoDB &amp; Node.js</title><meta name="description" content="We will explore about the grpc, which is the better version of the basic HTTP1.1 and make communications more faster between client-server"/><meta property="og:title" content="Create GRPC With MongoDB &amp; Node.js"/><meta property="og:description" content="We will explore about the grpc, which is the better version of the basic HTTP1.1 and make communications more faster between client-server"/><meta property="og:type" content="article"/><meta property="og:url" content="https://barbarpotato.github.io/labs/undefined"/><meta name="next-head-count" content="8"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/Labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/Labs/_next/static/chunks/webpack-a39982bd6f80347b.js" defer=""></script><script src="/Labs/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/Labs/_next/static/chunks/main-1e09b50edce1e67f.js" defer=""></script><script src="/Labs/_next/static/chunks/pages/_app-753213cf38d40131.js" defer=""></script><script src="/Labs/_next/static/chunks/pages/labs/%5Bslug%5D-b6b888b0a2f30cff.js" defer=""></script><script src="/Labs/_next/static/A-n-baZxhaPab-FReiSSJ/_buildManifest.js" defer=""></script><script src="/Labs/_next/static/A-n-baZxhaPab-FReiSSJ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><article><h1>Create GRPC With MongoDB &amp; Node.js</h1><p>2024-09-20 11:34:55</p><div><div id="content-1"><h1>What is GRPC?</h1><p>gRPC (Google Remote Procedure Call) is a high-performance, open-source framework developed by Google that enables efficient communication between distributed systems using remote procedure calls (RPCs). It leverages HTTP/2 for transport, Protocol Buffers (protobuf) for serialization, and supports features like multiplexing, streaming, and low-latency communication, making it ideal for modern microservices architectures and real-time applications. gRPC is increasingly used in this era due to its ability to handle complex, high-throughput workloads while ensuring consistent, language-agnostic communication between services, which is crucial for building scalable, resilient, and performant systems.</p><p>gRPC is highly relevant today due to its efficient communication using Protocol Buffers for serialization, which reduces message sizes and improves performance. It leverages HTTP/2 for lower latency and higher throughput, supports multiple programming languages, and provides strongly typed contracts for consistency. With built-in support for streaming, SSL/TLS for security, and automatic code generation, gRPC enhances development speed and ensures secure, real-time communication. Its compatibility with cloud-native platforms and microservices architectures further makes it a valuable tool for modern distributed systems.</p></div><div id="content-2"><img style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc_architecture.png?alt=media&token=fff5674e-8a0b-4e46-805d-feed5b3cf0f5'/></div><div id="content-4"><p>The basic architecture of gRPC involves several key components that facilitate communication between a client and server. Here's a breakdown of the architecture:</p><h3>1.&nbsp;<strong>Protocol Buffers (Protobufs):</strong></h3><ul><li><strong>Definition Language</strong>: Protobufs are used to define the service methods and message types. These definitions are stored in&nbsp;<code>.proto</code>&nbsp;files.</li><li><strong>Serialization</strong>: Protobufs serialize data into a compact binary format, which is efficient for transmission.</li></ul><h3>2.&nbsp;<strong>Service Definition:</strong></h3><ul><li><strong>Service Interface</strong>: In the&nbsp;<code>.proto</code>&nbsp;file, services are defined with methods that can be called remotely by clients. Each method specifies the request and response message types.</li></ul><h3>3.&nbsp;<strong>Code Generation:</strong></h3><ul><li><strong>Client and Server Stubs</strong>: The&nbsp;<code>.proto</code>&nbsp;file is used to generate client and server code in various languages. These stubs handle the serialization and deserialization of messages and the underlying gRPC protocol details.</li></ul><h3>4.&nbsp;<strong>Client-Side:</strong></h3><ul><li><strong>Stub</strong>: The client uses a generated stub to invoke methods on the server. The stub provides a local representation of the remote service.</li><li><strong>Channel</strong>: The client creates a communication channel to the server, which manages the connection and handles the low-level details of the communication.</li></ul><h3>5.&nbsp;<strong>Server-Side:</strong></h3><ul><li><strong>Implementation</strong>: The server implements the service methods defined in the&nbsp;<code>.proto</code>&nbsp;file. These methods process incoming requests and generate responses.</li><li><strong>Server</strong>: The server listens for incoming requests, dispatches them to the appropriate service method implementations, and sends back responses.</li></ul><h3>6.&nbsp;<strong>Communication:</strong></h3><ul><li><strong>HTTP/2</strong>: gRPC uses HTTP/2 as the transport protocol, providing features like multiplexing, flow control, and header compression.</li><li><strong>Streams</strong>: gRPC supports different types of RPCs, including unary (single request/response), server streaming, client streaming, and bidirectional streaming.</li></ul></div><div id="content-5"><h1>Basic gRPC Workflow:</h1><ol><li><strong>Define the Service</strong>: Create a <code>.proto</code> file with service and message definitions.</li><li><strong>Generate Code</strong>: Use the <code>protoc</code> compiler to generate client and server code from the <code>.proto</code> file.</li><li><strong>Implement the Server</strong>: Write the server-side code to implement the service methods.</li><li><strong>Create the Client</strong>: Write the client-side code to call the service methods using the generated stub.</li><li><strong>Establish Communication</strong>: The client and server communicate over a channel using HTTP/2, with data serialized and deserialized using Protobufs.</li></ol></div><div id="content-8"><h3>In gRPC, the client can indeed send data to the server. gRPC supports several types of communication patterns, including:</h3><h3>1. Unary RPC:</h3><ul><li>The client sends a single request to the server and receives a single response.</li></ul></div><div id="content-9"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">rpc SayHello (HelloRequest) returns (HelloReply) {}</code></pre></div><div id="content-10"><h3>2. Server Streaming RPC:</h3><ul><li>The client sends a single request to the server and receives a stream of responses.</li></ul></div><div id="content-11"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">rpc ListFeatures (Rectangle) returns (stream Feature) {}</code></pre></div><div id="content-12"><h3>3. Client Streaming RPC:</h3><ul><li>The client sends a stream of requests to the server and receives a single response.</li></ul></div><div id="content-13"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">rpc RecordRoute (stream Point) returns (RouteSummary) {}</code></pre></div><div id="content-14"><h3>4. Bidirectional Streaming RPC:</h3><ul><li>Both the client and server send a stream of messages to each other.</li></ul></div><div id="content-15"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">rpc RouteChat (stream RouteNote) returns (stream RouteNote) {}</code></pre></div><div id="content-16"><h1>Example</h1></div><div id="content-19"><p>Let's try to do the key list that we define in above. in this example we are going to implement the unary RPC for the sake of the simplicity. and in this example we are going to implement the grpc within the node.js with the helper of our beloved database called MongoDb. for this example what we are going to achieve is the client side can search the book data from the mongodb database. To ensure that the client can get the data successfully, the client side need to get interact with our grpc server. in a nutshell, the server side grpc will serve the client side. To create a gRPC server in Node.js, we need to install the required packages:</p></div><div id="content-20"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">npm install @grpc/grpc-js @grpc/proto-loader
</code></pre></div><div id="content-21"><p>after the installation is complete, we then create a proto file. in this file we define the service and the message that we are going to build. here is the example code:</p></div><div id="content-22"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">syntax = "proto3";

service Book {
  rpc GetBook (GetBookRequest) returns (BookReply) {}
}

message GetBookRequest {
  string Title = 1;
}

message BookReply {
  string Title = 1;
  string Author = 2;
  int32 Published = 3;
  string Language = 4;
  string Id = 5;
  int32 Sales = 6;
}</code></pre></div><div id="content-23"><p>the proto file is ready. now we can load it up trough our core script to running our node server. dont forget that we are using the mongodb database. so the first step is to setup the connection between the mongodb and the server, and then we build up the grpc service in a top of mongodb service.</p></div><div id="content-32"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');
const path = require('path');
const { MongoClient } = require('mongodb');

// Load the protobuf file
const PROTO_PATH = path.resolve(__dirname, 'service.proto');
const packageDefinition = protoLoader.loadSync(PROTO_PATH);
const proto = grpc.loadPackageDefinition(packageDefinition);

// MongoDB connection URL and Database name
const url = 'mongodb://localhost:27017';
const dbName = 'Book';

let db;
let client;

// Connect to MongoDB and start gRPC server
async function main() {
    const client = new MongoClient(url);

    try {
        await client.connect();
        console.log('Connected to MongoDB');
        db = client.db(dbName);

        // Start gRPC server after MongoDB connection
        startGrpcServer();
    } catch (e) {
        console.error('Failed to connect to MongoDB', e);
    } finally {
        // Ensure MongoClient is closed if needed
        // Uncomment if you need to close the client here:
        // await client.close();
    }
}


// gRPC service method
function GetBook(call, callback) {
    console.log('Received request:', call.request);
    const { Title } = call.request;
    const collection = db.collection('list');

    console.log('Performing findOne query with Book:', Title);
    collection.findOne({ Book: Title }, { maxTimeMS: 5000 })
        .then(result =&gt; {
            console.log('findOne query completed');
            if (result) {
                const response = {
                    Title: result.Book,
                    Author: result['Author(s)'], // Adjusted field names
                    Published: result['First published'],
                    Language: result['Original language'],
                    Id: result._id.toString(),
                    Sales: result['Approximate sales in millions']
                };
                console.log('Sending response:', response);
                callback(null, response);
            } else {
                console.log('Book not found');
                callback(null, { Title: "Book not found" });
            }
        })
        .catch(err =&gt; {
            console.error('Error fetching data:', err);
            callback(err, null);
        });
}


// Start the gRPC server
function startGrpcServer() {
    const server = new grpc.Server();
    server.addService(proto.Book.service, { GetBook: GetBook });
    const port = '50051';
    server.bindAsync(`0.0.0.0:${port}`, grpc.ServerCredentials.createInsecure(), (error, port) =&gt; {
        if (error) {
            console.error(`Failed to bind server: ${error.message}`);
            process.exit(1); // Exit process if server fails to start
        }
        console.log(`Server running at http://0.0.0.0:${port}`);
    });
}

// Run the main function
main();</code></pre></div><div id="content-33"><p>We can now run the server. by using the command node &lt;the name of your server code file&gt;</p></div><div id="content-34"><img style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc-step-1.png?alt=media&token=cef277a6-d5e2-45d9-80f2-6871e3715089'/></div><div id="content-35"><p>The setup and implementation of the server.js is completed. now we move to the code of the client side. which is more simple. here is the code to call the available service from the server side that we implement previously. where in here we can access the GetBook service. and try to search the field named book with value&nbsp;Where the Crawdads Sing</p></div><div id="content-36"><pre style="background-color: black; color: white; padding:10px; border-radius: 5px;"><code style="color: white;">const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');
const path = require('path');

// Load the protobuf file
const PROTO_PATH = path.resolve(__dirname, 'service.proto');
const packageDefinition = protoLoader.loadSync(PROTO_PATH);
const proto = grpc.loadPackageDefinition(packageDefinition);

// Create a new gRPC client
const client = new proto.Book('localhost:50051', grpc.credentials.createInsecure());

// Call the service
client.GetBook({ Title: 'Where the Crawdads Sing' }, (error, response) =&gt; {
    if (error) {
        console.error(`Error: ${error.message}`);
    } else {
        console.log(`Response: ${JSON.stringify(response)}`);
    }
});
</code></pre></div><div id="content-37"><p>We can run this client side. and it the result of the book that we search is delivered to the client side.</p></div><div id="content-38"><img style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc-step-2.png?alt=media&token=85d657cc-6260-492d-a70e-62d26b038da2'/></div><div id="content-40"><h1>Conclusion</h1><p>gRPC is a powerful framework for building efficient, high-performance communication between distributed systems. By leveraging HTTP/2 and Protocol Buffers (protobuf), gRPC enables low-latency, scalable interactions ideal for microservices and real-time applications. In this example, we demonstrated how to set up a gRPC server in Node.js that interacts with a MongoDB database. We defined a service using Protocol Buffers, implemented the server to handle requests, and created a client to query book data. This approach allows for efficient data retrieval and robust communication between client and server, showcasing gRPC's capabilities in modern software development. By understanding gRPC's architecture and workflow, and implementing it in a real-world scenario, you can build scalable, high-performance systems that handle complex workloads with ease.</p></div></div></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"blog_id":"82db10ae-f820-45d6-b985-9ac22fa7046f","description":"\u003cdiv id=\"content-1\"\u003e\u003ch1\u003eWhat is GRPC?\u003c/h1\u003e\u003cp\u003egRPC (Google Remote Procedure Call) is a high-performance, open-source framework developed by Google that enables efficient communication between distributed systems using remote procedure calls (RPCs). It leverages HTTP/2 for transport, Protocol Buffers (protobuf) for serialization, and supports features like multiplexing, streaming, and low-latency communication, making it ideal for modern microservices architectures and real-time applications. gRPC is increasingly used in this era due to its ability to handle complex, high-throughput workloads while ensuring consistent, language-agnostic communication between services, which is crucial for building scalable, resilient, and performant systems.\u003c/p\u003e\u003cp\u003egRPC is highly relevant today due to its efficient communication using Protocol Buffers for serialization, which reduces message sizes and improves performance. It leverages HTTP/2 for lower latency and higher throughput, supports multiple programming languages, and provides strongly typed contracts for consistency. With built-in support for streaming, SSL/TLS for security, and automatic code generation, gRPC enhances development speed and ensures secure, real-time communication. Its compatibility with cloud-native platforms and microservices architectures further makes it a valuable tool for modern distributed systems.\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-2\"\u003e\u003cimg style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc_architecture.png?alt=media\u0026token=fff5674e-8a0b-4e46-805d-feed5b3cf0f5'/\u003e\u003c/div\u003e\u003cdiv id=\"content-4\"\u003e\u003cp\u003eThe basic architecture of gRPC involves several key components that facilitate communication between a client and server. Here's a breakdown of the architecture:\u003c/p\u003e\u003ch3\u003e1.\u0026nbsp;\u003cstrong\u003eProtocol Buffers (Protobufs):\u003c/strong\u003e\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eDefinition Language\u003c/strong\u003e: Protobufs are used to define the service methods and message types. These definitions are stored in\u0026nbsp;\u003ccode\u003e.proto\u003c/code\u003e\u0026nbsp;files.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eSerialization\u003c/strong\u003e: Protobufs serialize data into a compact binary format, which is efficient for transmission.\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003e2.\u0026nbsp;\u003cstrong\u003eService Definition:\u003c/strong\u003e\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eService Interface\u003c/strong\u003e: In the\u0026nbsp;\u003ccode\u003e.proto\u003c/code\u003e\u0026nbsp;file, services are defined with methods that can be called remotely by clients. Each method specifies the request and response message types.\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003e3.\u0026nbsp;\u003cstrong\u003eCode Generation:\u003c/strong\u003e\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eClient and Server Stubs\u003c/strong\u003e: The\u0026nbsp;\u003ccode\u003e.proto\u003c/code\u003e\u0026nbsp;file is used to generate client and server code in various languages. These stubs handle the serialization and deserialization of messages and the underlying gRPC protocol details.\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003e4.\u0026nbsp;\u003cstrong\u003eClient-Side:\u003c/strong\u003e\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eStub\u003c/strong\u003e: The client uses a generated stub to invoke methods on the server. The stub provides a local representation of the remote service.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eChannel\u003c/strong\u003e: The client creates a communication channel to the server, which manages the connection and handles the low-level details of the communication.\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003e5.\u0026nbsp;\u003cstrong\u003eServer-Side:\u003c/strong\u003e\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eImplementation\u003c/strong\u003e: The server implements the service methods defined in the\u0026nbsp;\u003ccode\u003e.proto\u003c/code\u003e\u0026nbsp;file. These methods process incoming requests and generate responses.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eServer\u003c/strong\u003e: The server listens for incoming requests, dispatches them to the appropriate service method implementations, and sends back responses.\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003e6.\u0026nbsp;\u003cstrong\u003eCommunication:\u003c/strong\u003e\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eHTTP/2\u003c/strong\u003e: gRPC uses HTTP/2 as the transport protocol, providing features like multiplexing, flow control, and header compression.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eStreams\u003c/strong\u003e: gRPC supports different types of RPCs, including unary (single request/response), server streaming, client streaming, and bidirectional streaming.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv id=\"content-5\"\u003e\u003ch1\u003eBasic gRPC Workflow:\u003c/h1\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eDefine the Service\u003c/strong\u003e: Create a \u003ccode\u003e.proto\u003c/code\u003e file with service and message definitions.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eGenerate Code\u003c/strong\u003e: Use the \u003ccode\u003eprotoc\u003c/code\u003e compiler to generate client and server code from the \u003ccode\u003e.proto\u003c/code\u003e file.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eImplement the Server\u003c/strong\u003e: Write the server-side code to implement the service methods.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eCreate the Client\u003c/strong\u003e: Write the client-side code to call the service methods using the generated stub.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eEstablish Communication\u003c/strong\u003e: The client and server communicate over a channel using HTTP/2, with data serialized and deserialized using Protobufs.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003cdiv id=\"content-8\"\u003e\u003ch3\u003eIn gRPC, the client can indeed send data to the server. gRPC supports several types of communication patterns, including:\u003c/h3\u003e\u003ch3\u003e1. Unary RPC:\u003c/h3\u003e\u003cul\u003e\u003cli\u003eThe client sends a single request to the server and receives a single response.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv id=\"content-9\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003erpc SayHello (HelloRequest) returns (HelloReply) {}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-10\"\u003e\u003ch3\u003e2. Server Streaming RPC:\u003c/h3\u003e\u003cul\u003e\u003cli\u003eThe client sends a single request to the server and receives a stream of responses.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv id=\"content-11\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003erpc ListFeatures (Rectangle) returns (stream Feature) {}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-12\"\u003e\u003ch3\u003e3. Client Streaming RPC:\u003c/h3\u003e\u003cul\u003e\u003cli\u003eThe client sends a stream of requests to the server and receives a single response.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv id=\"content-13\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003erpc RecordRoute (stream Point) returns (RouteSummary) {}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-14\"\u003e\u003ch3\u003e4. Bidirectional Streaming RPC:\u003c/h3\u003e\u003cul\u003e\u003cli\u003eBoth the client and server send a stream of messages to each other.\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv id=\"content-15\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003erpc RouteChat (stream RouteNote) returns (stream RouteNote) {}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-16\"\u003e\u003ch1\u003eExample\u003c/h1\u003e\u003c/div\u003e\u003cdiv id=\"content-19\"\u003e\u003cp\u003eLet's try to do the key list that we define in above. in this example we are going to implement the unary RPC for the sake of the simplicity. and in this example we are going to implement the grpc within the node.js with the helper of our beloved database called MongoDb. for this example what we are going to achieve is the client side can search the book data from the mongodb database. To ensure that the client can get the data successfully, the client side need to get interact with our grpc server. in a nutshell, the server side grpc will serve the client side. To create a gRPC server in Node.js, we need to install the required packages:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-20\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003enpm install @grpc/grpc-js @grpc/proto-loader\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-21\"\u003e\u003cp\u003eafter the installation is complete, we then create a proto file. in this file we define the service and the message that we are going to build. here is the example code:\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-22\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003esyntax = \"proto3\";\n\nservice Book {\n  rpc GetBook (GetBookRequest) returns (BookReply) {}\n}\n\nmessage GetBookRequest {\n  string Title = 1;\n}\n\nmessage BookReply {\n  string Title = 1;\n  string Author = 2;\n  int32 Published = 3;\n  string Language = 4;\n  string Id = 5;\n  int32 Sales = 6;\n}\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-23\"\u003e\u003cp\u003ethe proto file is ready. now we can load it up trough our core script to running our node server. dont forget that we are using the mongodb database. so the first step is to setup the connection between the mongodb and the server, and then we build up the grpc service in a top of mongodb service.\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-32\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003econst grpc = require('@grpc/grpc-js');\nconst protoLoader = require('@grpc/proto-loader');\nconst path = require('path');\nconst { MongoClient } = require('mongodb');\n\n// Load the protobuf file\nconst PROTO_PATH = path.resolve(__dirname, 'service.proto');\nconst packageDefinition = protoLoader.loadSync(PROTO_PATH);\nconst proto = grpc.loadPackageDefinition(packageDefinition);\n\n// MongoDB connection URL and Database name\nconst url = 'mongodb://localhost:27017';\nconst dbName = 'Book';\n\nlet db;\nlet client;\n\n// Connect to MongoDB and start gRPC server\nasync function main() {\n    const client = new MongoClient(url);\n\n    try {\n        await client.connect();\n        console.log('Connected to MongoDB');\n        db = client.db(dbName);\n\n        // Start gRPC server after MongoDB connection\n        startGrpcServer();\n    } catch (e) {\n        console.error('Failed to connect to MongoDB', e);\n    } finally {\n        // Ensure MongoClient is closed if needed\n        // Uncomment if you need to close the client here:\n        // await client.close();\n    }\n}\n\n\n// gRPC service method\nfunction GetBook(call, callback) {\n    console.log('Received request:', call.request);\n    const { Title } = call.request;\n    const collection = db.collection('list');\n\n    console.log('Performing findOne query with Book:', Title);\n    collection.findOne({ Book: Title }, { maxTimeMS: 5000 })\n        .then(result =\u0026gt; {\n            console.log('findOne query completed');\n            if (result) {\n                const response = {\n                    Title: result.Book,\n                    Author: result['Author(s)'], // Adjusted field names\n                    Published: result['First published'],\n                    Language: result['Original language'],\n                    Id: result._id.toString(),\n                    Sales: result['Approximate sales in millions']\n                };\n                console.log('Sending response:', response);\n                callback(null, response);\n            } else {\n                console.log('Book not found');\n                callback(null, { Title: \"Book not found\" });\n            }\n        })\n        .catch(err =\u0026gt; {\n            console.error('Error fetching data:', err);\n            callback(err, null);\n        });\n}\n\n\n// Start the gRPC server\nfunction startGrpcServer() {\n    const server = new grpc.Server();\n    server.addService(proto.Book.service, { GetBook: GetBook });\n    const port = '50051';\n    server.bindAsync(`0.0.0.0:${port}`, grpc.ServerCredentials.createInsecure(), (error, port) =\u0026gt; {\n        if (error) {\n            console.error(`Failed to bind server: ${error.message}`);\n            process.exit(1); // Exit process if server fails to start\n        }\n        console.log(`Server running at http://0.0.0.0:${port}`);\n    });\n}\n\n// Run the main function\nmain();\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-33\"\u003e\u003cp\u003eWe can now run the server. by using the command node \u0026lt;the name of your server code file\u0026gt;\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-34\"\u003e\u003cimg style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc-step-1.png?alt=media\u0026token=cef277a6-d5e2-45d9-80f2-6871e3715089'/\u003e\u003c/div\u003e\u003cdiv id=\"content-35\"\u003e\u003cp\u003eThe setup and implementation of the server.js is completed. now we move to the code of the client side. which is more simple. here is the code to call the available service from the server side that we implement previously. where in here we can access the GetBook service. and try to search the field named book with value\u0026nbsp;Where the Crawdads Sing\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-36\"\u003e\u003cpre style=\"background-color: black; color: white; padding:10px; border-radius: 5px;\"\u003e\u003ccode style=\"color: white;\"\u003econst grpc = require('@grpc/grpc-js');\nconst protoLoader = require('@grpc/proto-loader');\nconst path = require('path');\n\n// Load the protobuf file\nconst PROTO_PATH = path.resolve(__dirname, 'service.proto');\nconst packageDefinition = protoLoader.loadSync(PROTO_PATH);\nconst proto = grpc.loadPackageDefinition(packageDefinition);\n\n// Create a new gRPC client\nconst client = new proto.Book('localhost:50051', grpc.credentials.createInsecure());\n\n// Call the service\nclient.GetBook({ Title: 'Where the Crawdads Sing' }, (error, response) =\u0026gt; {\n    if (error) {\n        console.error(`Error: ${error.message}`);\n    } else {\n        console.log(`Response: ${JSON.stringify(response)}`);\n    }\n});\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv id=\"content-37\"\u003e\u003cp\u003eWe can run this client side. and it the result of the book that we search is delivered to the client side.\u003c/p\u003e\u003c/div\u003e\u003cdiv id=\"content-38\"\u003e\u003cimg style='width:720px;' src='https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc-step-2.png?alt=media\u0026token=85d657cc-6260-492d-a70e-62d26b038da2'/\u003e\u003c/div\u003e\u003cdiv id=\"content-40\"\u003e\u003ch1\u003eConclusion\u003c/h1\u003e\u003cp\u003egRPC is a powerful framework for building efficient, high-performance communication between distributed systems. By leveraging HTTP/2 and Protocol Buffers (protobuf), gRPC enables low-latency, scalable interactions ideal for microservices and real-time applications. In this example, we demonstrated how to set up a gRPC server in Node.js that interacts with a MongoDB database. We defined a service using Protocol Buffers, implemented the server to handle requests, and created a client to query book data. This approach allows for efficient data retrieval and robust communication between client and server, showcasing gRPC's capabilities in modern software development. By understanding gRPC's architecture and workflow, and implementing it in a real-world scenario, you can build scalable, high-performance systems that handle complex workloads with ease.\u003c/p\u003e\u003c/div\u003e","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fgrpc_background.png?alt=media\u0026token=3df4f4c7-ea5f-4170-ae16-6656671bfd4a","image_alt":"GRPC Background","short_description":"We will explore about the grpc, which is the better version of the basic HTTP1.1 and make communications more faster between client-server","timestamp":"2024-09-20 11:34:55","title":"Create GRPC With MongoDB \u0026 Node.js"}},"__N_SSG":true},"page":"/labs/[slug]","query":{"slug":"82db10ae-f820-45d6-b985-9ac22fa7046f"},"buildId":"A-n-baZxhaPab-FReiSSJ","assetPrefix":"/Labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>