<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>The concept of splitting a frontend into smaller, manageable pieces.</title><meta name="description" content="Have you ever worked on a massive frontend application where every change felt risky and deploying updates took ages? If so, micro frontends might be the solution you’ve been looking for"/><meta property="og:title" content="The concept of splitting a frontend into smaller, manageable pieces."/><meta property="og:description" content="Have you ever worked on a massive frontend application where every change felt risky and deploying updates took ages? If so, micro frontends might be the solution you’ve been looking for"/><meta property="og:type" content="article"/><meta property="og:url" content="https://barbarpotato.github.io/labs/undefined"/><meta name="next-head-count" content="8"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/Labs/_next/static/chunks/polyfills-78c92fac7aa8fdd8.js"></script><script src="/Labs/_next/static/chunks/webpack-a39982bd6f80347b.js" defer=""></script><script src="/Labs/_next/static/chunks/framework-ecc4130bc7a58a64.js" defer=""></script><script src="/Labs/_next/static/chunks/main-1e09b50edce1e67f.js" defer=""></script><script src="/Labs/_next/static/chunks/pages/_app-753213cf38d40131.js" defer=""></script><script src="/Labs/_next/static/chunks/pages/labs/%5Bslug%5D-b6b888b0a2f30cff.js" defer=""></script><script src="/Labs/_next/static/A-n-baZxhaPab-FReiSSJ/_buildManifest.js" defer=""></script><script src="/Labs/_next/static/A-n-baZxhaPab-FReiSSJ/_ssgManifest.js" defer=""></script></head><body><div id="__next"><article><h1>The concept of splitting a frontend into smaller, manageable pieces.</h1><p>2024-12-04 11:23:45</p><div><p>Micro frontends are an architectural approach that applies the principles of microservices to frontend development. Instead of building a single, monolithic frontend application, the user interface is divided into smaller, independent pieces called <strong>micro frontends</strong>, each of which is developed, deployed, and maintained independently.</p><h1><strong>The Problem with Monolithic Frontends</strong></h1><p>A <strong>monolithic frontend</strong> refers to a single, large codebase that manages the entire user interface of an application. While this approach works well for small applications, it becomes increasingly challenging to manage and scale as the application and development teams grow. Below are the key problems associated with monolithic frontends:</p><h2><strong>1. Scaling Teams</strong></h2><ul><li><strong>Coordination Overhead</strong>: In a large team, multiple developers work on the same codebase. This can lead to frequent merge conflicts, delayed pull requests, and dependency issues.</li><li><strong>Limited Parallel Development</strong>: Because the codebase is tightly coupled, teams cannot work independently on different parts of the application without stepping on each other's toes.</li></ul><h2><strong>2. Slower Development Cycles</strong></h2><ul><li><strong>Single Deployment Pipeline</strong>: In a monolithic frontend, all changes must pass through the same build and deployment pipeline. This means Small changes (e.g., fixing a typo) require deploying the entire application, also A single bug can block the entire release process.</li><li><strong>Longer Testing Time</strong>: The larger the application, the more time and effort it takes to ensure that new changes don’t break existing functionality.</li></ul><h2><strong>3. High Risk of Changes</strong></h2><ul><li><strong>Ripple Effect</strong>: Since everything is interconnected, even small changes in one part of the application can have unintended consequences elsewhere.</li><li><strong>Rollback Challenges</strong>: If something goes wrong after deployment, rolling back requires reverting the entire application, not just the problematic component.</li></ul><h2><strong>4. Tech Stack Lock-In</strong></h2><ul><li><strong>Difficult to Adopt New Frameworks</strong>: In a monolithic frontend, the entire application is built using a single framework or library. Upgrading or switching technologies is a monumental task that may require rewriting the entire application. <strong>Example</strong>: Migrating from AngularJS to React would involve significant effort and downtime.</li><li><strong>No Flexibility for Teams</strong>: Teams must stick to the same tech stack, even if certain parts of the application would benefit from newer or more suitable tools.</li></ul><h1><strong>How Micro Frontends Work</strong></h1><p>Micro frontends operate on the principle of <strong>divide and conquer</strong>. Instead of managing one gigantic codebase, you divide your application into smaller units.</p><p>The idea behind micro frontends is simple yet powerful:</p><p><strong>1. Divide</strong> your application into smaller, self-contained pieces.</p><p><strong>2. Conquer</strong> by developing, testing, and deploying these pieces independently.</p><p>Instead of one massive codebase where every change has the potential to disrupt the entire application, you get a collection of smaller, focused units that can evolve at their own pace. Here is the breakdown of how divide and conquer works in microfrontend.</p><p><br></p><p><img src="https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fmonolit_vs_microfrontend.png?alt=media&amp;token=24eba3d8-b7f3-4674-b33e-62daf0517afd" alt="Monolithic Vs Microfrontend" width="720px"></p><p><br></p><p>In a traditional monolithic architecture (left side), all components of a web application are tightly coupled and deployed as a single unit. This includes the web application layer (frontend), integration layer (APIs), and service layer (backend).</p><p>Microfrontends (right side) break down a large web application into smaller, independent frontend applications (also called "micro-applications" or "micro-frontends"). Each microfrontend is responsible for a specific feature or section of the application. This approach promotes modularity, scalability, and faster development cycles.</p><p>The divide and conquer approach is central to microfrontends. It involves:</p><h3><strong>Dividing the Application:</strong></h3><ol><li><strong>Identify Features:</strong> First, break down the application into distinct features or sections. For example, in the image, we have "Cart," "Website," and "Payment" as separate features.</li><li><strong>Assign Teams:</strong> Each feature is assigned to an independent team. This allows teams to work autonomously, focusing on their specific feature.</li></ol><h3><strong>Conquering the Features:</strong></h3><ol><li><strong>Independent Development:</strong> Each team develops its feature as a standalone frontend application. They can use different technologies (React, JAML, etc.) and frameworks as needed.</li><li><strong>API Integration:</strong> Teams define clear APIs for their microfrontends to communicate with each other and with the backend services. This ensures loose coupling and flexibility.</li></ol><h3><strong>Composition and Orchestration:</strong></h3><ol><li><strong>Frameworks and Tools:</strong> A framework or library is used to combine the microfrontends into a cohesive user experience. This can be done using techniques like server-side composition (e.g., with a Node.js server) or client-side composition (e.g., with a JavaScript framework like Single-SPA).</li><li><strong>Routing and Navigation:</strong> The framework handles routing and navigation between microfrontends, ensuring a seamless user experience.</li><li><strong>Shared Components:</strong> If necessary, shared components can be developed and used across multiple microfrontends. This promotes consistency and reduces code duplication.</li></ol><h1>Conclusion</h1><p>Micro frontends represent a modern approach to building scalable, resilient, and maintainable frontend applications. By breaking down your application into smaller, independent pieces, you empower your teams to innovate faster and reduce deployment risks.. If you’ve ever felt constrained by the limitations of a monolithic frontend, it might be time to explore the possibilities of micro frontends. They’re not just a technical solution—they’re a way to rethink how we build for the web.</p></div></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"blog_id":"e7d3943c-c12a-42c1-9663-2d90449138dc","description":"\u003cp\u003eMicro frontends are an architectural approach that applies the principles of microservices to frontend development. Instead of building a single, monolithic frontend application, the user interface is divided into smaller, independent pieces called \u003cstrong\u003emicro frontends\u003c/strong\u003e, each of which is developed, deployed, and maintained independently.\u003c/p\u003e\u003ch1\u003e\u003cstrong\u003eThe Problem with Monolithic Frontends\u003c/strong\u003e\u003c/h1\u003e\u003cp\u003eA \u003cstrong\u003emonolithic frontend\u003c/strong\u003e refers to a single, large codebase that manages the entire user interface of an application. While this approach works well for small applications, it becomes increasingly challenging to manage and scale as the application and development teams grow. Below are the key problems associated with monolithic frontends:\u003c/p\u003e\u003ch2\u003e\u003cstrong\u003e1. Scaling Teams\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eCoordination Overhead\u003c/strong\u003e: In a large team, multiple developers work on the same codebase. This can lead to frequent merge conflicts, delayed pull requests, and dependency issues.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLimited Parallel Development\u003c/strong\u003e: Because the codebase is tightly coupled, teams cannot work independently on different parts of the application without stepping on each other's toes.\u003c/li\u003e\u003c/ul\u003e\u003ch2\u003e\u003cstrong\u003e2. Slower Development Cycles\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eSingle Deployment Pipeline\u003c/strong\u003e: In a monolithic frontend, all changes must pass through the same build and deployment pipeline. This means Small changes (e.g., fixing a typo) require deploying the entire application, also A single bug can block the entire release process.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLonger Testing Time\u003c/strong\u003e: The larger the application, the more time and effort it takes to ensure that new changes don’t break existing functionality.\u003c/li\u003e\u003c/ul\u003e\u003ch2\u003e\u003cstrong\u003e3. High Risk of Changes\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eRipple Effect\u003c/strong\u003e: Since everything is interconnected, even small changes in one part of the application can have unintended consequences elsewhere.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eRollback Challenges\u003c/strong\u003e: If something goes wrong after deployment, rolling back requires reverting the entire application, not just the problematic component.\u003c/li\u003e\u003c/ul\u003e\u003ch2\u003e\u003cstrong\u003e4. Tech Stack Lock-In\u003c/strong\u003e\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eDifficult to Adopt New Frameworks\u003c/strong\u003e: In a monolithic frontend, the entire application is built using a single framework or library. Upgrading or switching technologies is a monumental task that may require rewriting the entire application. \u003cstrong\u003eExample\u003c/strong\u003e: Migrating from AngularJS to React would involve significant effort and downtime.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eNo Flexibility for Teams\u003c/strong\u003e: Teams must stick to the same tech stack, even if certain parts of the application would benefit from newer or more suitable tools.\u003c/li\u003e\u003c/ul\u003e\u003ch1\u003e\u003cstrong\u003eHow Micro Frontends Work\u003c/strong\u003e\u003c/h1\u003e\u003cp\u003eMicro frontends operate on the principle of \u003cstrong\u003edivide and conquer\u003c/strong\u003e. Instead of managing one gigantic codebase, you divide your application into smaller units.\u003c/p\u003e\u003cp\u003eThe idea behind micro frontends is simple yet powerful:\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1. Divide\u003c/strong\u003e your application into smaller, self-contained pieces.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2. Conquer\u003c/strong\u003e by developing, testing, and deploying these pieces independently.\u003c/p\u003e\u003cp\u003eInstead of one massive codebase where every change has the potential to disrupt the entire application, you get a collection of smaller, focused units that can evolve at their own pace. Here is the breakdown of how divide and conquer works in microfrontend.\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fmonolit_vs_microfrontend.png?alt=media\u0026amp;token=24eba3d8-b7f3-4674-b33e-62daf0517afd\" alt=\"Monolithic Vs Microfrontend\" width=\"720px\"\u003e\u003c/p\u003e\u003cp\u003e\u003cbr\u003e\u003c/p\u003e\u003cp\u003eIn a traditional monolithic architecture (left side), all components of a web application are tightly coupled and deployed as a single unit. This includes the web application layer (frontend), integration layer (APIs), and service layer (backend).\u003c/p\u003e\u003cp\u003eMicrofrontends (right side) break down a large web application into smaller, independent frontend applications (also called \"micro-applications\" or \"micro-frontends\"). Each microfrontend is responsible for a specific feature or section of the application. This approach promotes modularity, scalability, and faster development cycles.\u003c/p\u003e\u003cp\u003eThe divide and conquer approach is central to microfrontends. It involves:\u003c/p\u003e\u003ch3\u003e\u003cstrong\u003eDividing the Application:\u003c/strong\u003e\u003c/h3\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eIdentify Features:\u003c/strong\u003e First, break down the application into distinct features or sections. For example, in the image, we have \"Cart,\" \"Website,\" and \"Payment\" as separate features.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eAssign Teams:\u003c/strong\u003e Each feature is assigned to an independent team. This allows teams to work autonomously, focusing on their specific feature.\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003e\u003cstrong\u003eConquering the Features:\u003c/strong\u003e\u003c/h3\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eIndependent Development:\u003c/strong\u003e Each team develops its feature as a standalone frontend application. They can use different technologies (React, JAML, etc.) and frameworks as needed.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eAPI Integration:\u003c/strong\u003e Teams define clear APIs for their microfrontends to communicate with each other and with the backend services. This ensures loose coupling and flexibility.\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003e\u003cstrong\u003eComposition and Orchestration:\u003c/strong\u003e\u003c/h3\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eFrameworks and Tools:\u003c/strong\u003e A framework or library is used to combine the microfrontends into a cohesive user experience. This can be done using techniques like server-side composition (e.g., with a Node.js server) or client-side composition (e.g., with a JavaScript framework like Single-SPA).\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eRouting and Navigation:\u003c/strong\u003e The framework handles routing and navigation between microfrontends, ensuring a seamless user experience.\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eShared Components:\u003c/strong\u003e If necessary, shared components can be developed and used across multiple microfrontends. This promotes consistency and reduces code duplication.\u003c/li\u003e\u003c/ol\u003e\u003ch1\u003eConclusion\u003c/h1\u003e\u003cp\u003eMicro frontends represent a modern approach to building scalable, resilient, and maintainable frontend applications. By breaking down your application into smaller, independent pieces, you empower your teams to innovate faster and reduce deployment risks.. If you’ve ever felt constrained by the limitations of a monolithic frontend, it might be time to explore the possibilities of micro frontends. They’re not just a technical solution—they’re a way to rethink how we build for the web.\u003c/p\u003e","image":"https://firebasestorage.googleapis.com/v0/b/personal-blog-darmajr.appspot.com/o/blog-content%2Fmicrofrontend.webp?alt=media\u0026token=6274c176-9622-4cd5-93be-9ea9e5912bd9","image_alt":"Microfrontend Image Cover","short_description":"Have you ever worked on a massive frontend application where every change felt risky and deploying updates took ages? If so, micro frontends might be the solution you’ve been looking for","timestamp":"2024-12-04 11:23:45","title":"The concept of splitting a frontend into smaller, manageable pieces."}},"__N_SSG":true},"page":"/labs/[slug]","query":{"slug":"e7d3943c-c12a-42c1-9663-2d90449138dc"},"buildId":"A-n-baZxhaPab-FReiSSJ","assetPrefix":"/Labs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>